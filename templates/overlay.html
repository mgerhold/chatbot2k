<!doctype html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="color-scheme" content="dark"/>
    <title>Overlay</title>
    <style>
        html, body { margin:0; height:100%; background:transparent; }
        .overlay-video {
          position: fixed;
          inset: 0;                 /* top:0; right:0; bottom:0; left:0 */
          width: 100vw;
          height: 100vh;
          background: #000;         /* letterbox background */
          pointer-events: none;     /* click-through overlay */
          z-index: 9999;
          object-fit: contain;      /* keep entire frame visible with letterboxing */
        }
        .hidden { display:none; }
    </style>
</head>
<body>

<script>
    (() => {
      const AUDIO_EXT = /\.(mp3|wav|ogg|flac|aac|m4a)(\?|$)/i;
      const VIDEO_EXT = /\.(mp4|webm|mov|mkv|m4v)(\?|$)/i;

      // --- NEW: keep track of currently playing elements by key (URL) ---
      const playing = new Map(); // key -> HTMLMediaElement

      // If you want to treat URLs with cache-busters as the same clip, normalize here.
      function canonicalKey(url) {
        try {
          const u = new URL(url, location.href);
          // Example: ignore a known cache-buster param:
          // u.searchParams.delete("t");
          // u.searchParams.delete("_");
          return u.toString();
        } catch {
          return url; // fallback for relative/invalid URLs
        }
      }

      async function primeAudio() {
        try {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (Ctx) await new Ctx().resume();
        } catch {}
      }

      function restartMedia(el) {
        // Ensure we jump to start once metadata is known
        if (el.readyState >= 1 /* HAVE_METADATA */) {
          try { typeof el.fastSeek === "function" ? el.fastSeek(0) : (el.currentTime = 0); } catch {}
        } else {
          const onMeta = () => {
            try { typeof el.fastSeek === "function" ? el.fastSeek(0) : (el.currentTime = 0); } catch {}
            el.removeEventListener("loadedmetadata", onMeta);
          };
          el.addEventListener("loadedmetadata", onMeta);
        }
        el.play();
      }

      function playClip(url) {
        const key = canonicalKey(url);
        const existing = playing.get(key);

        if (existing && !existing.ended && !existing._disposed) {
          // Same clip already playing -> restart it (no overlap)
          restartMedia(existing);
          return;
        } else if (existing) {
          // It ended or was disposed; clean mapping
          playing.delete(key);
        }

        // Create a fresh media element
        const isAudio = AUDIO_EXT.test(url) && !VIDEO_EXT.test(url);
        const el = document.createElement(isAudio ? "audio" : "video");
        el.src = url;
        el.preload = "auto";
        el.autoplay = true;
        el.crossOrigin = "anonymous";
        if (!isAudio) {
          el.className = "overlay-video";
          el.playsInline = true;
          el.muted = false;
          el.controls = false;
        } else {
          el.className = "overlay-audio";
          el.style.display = "none"; // audio is invisible
        }

        document.body.appendChild(el);
        playing.set(key, el);

        const playPromise = el.play();
        if (playPromise && typeof playPromise.then === "function") {
          playPromise.catch(() => {
            dispose();
          });
        }

        function dispose() {
          if (el._disposed) return;
          el._disposed = true;
          try { el.pause(); } catch {}
          try { el.removeAttribute("src"); el.load?.(); } catch {}
          try { el.remove(); } catch {}
          if (playing.get(key) === el) playing.delete(key);
        }

        el.addEventListener("ended", dispose);
        el.addEventListener("error", dispose);
        // Optional: force cleanup if it somehow hangs paused at end
        el.addEventListener("pause", () => { if (el.ended) dispose(); });
      }

      // ---- SSE hookup with auto-reconnect ----
      let eventSource = null;
      const RECONNECT_DELAY = 5000; // 5 seconds
      
      function connect() {
        if (eventSource) {
          try { eventSource.close(); } catch {}
          eventSource = null;
        }

        eventSource = new EventSource('overlay/events');
        
        eventSource.onopen = () => {
          console.log('SSE connected');
        };

        eventSource.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);
            if (data && typeof data.clip_url === "string" && data.clip_url.length) {
              playClip(data.clip_url);
            }
          } catch {}
        };

        eventSource.onerror = () => {
          console.log('SSE connection error, attempting to reconnect...');
          eventSource.close();
          
          setTimeout(connect, RECONNECT_DELAY);
        };
      }

      connect();
      primeAudio();
    })();
</script>
</body>
</html>
